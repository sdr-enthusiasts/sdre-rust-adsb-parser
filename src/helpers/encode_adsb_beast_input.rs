// Copyright (c) 2023-2024 Frederick Clausen II

// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

use crate::error_handling::adsb_beast_error::ADSBBeastError;

const ADSB_BEAST_START_CHARACTER: u8 = 0x1a; // The adsb beast end character sequence is is a '0x3b0a', start is '0x2a'
const ADSB_BEAST_LONG_FRAME_START_CHARACTER: u8 = 0x33;
const ADSB_BEAST_SHORT_FRAME_START_CHARACTER: u8 = 0x32;
const ADSB_BEAST_MODEAC_FRAME_START_CHARACTER: u8 = 0x31;
const ADSB_BEAST_SHORT_FRAME_LENGTH: usize = 15;
const ADSB_BEAST_LONG_FRAME_LENGTH: usize = 22;
const ADSB_BEAST_MODEAC_FRAME_LENGTH: usize = 10;

pub struct ADSBBeastFrames {
    pub frames: Vec<Vec<u8>>,
    pub left_over: Vec<u8>,
    pub errors: Vec<ADSBBeastError>,
}

impl ADSBBeastFrames {
    #[must_use]
    pub fn len(&self) -> usize {
        self.frames.len()
    }
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.frames.is_empty()
    }
}

#[derive(Debug, PartialEq, PartialOrd)]
enum FrameType {
    Short,
    Long,
    ModeAC,
    None,
}

/// Helper function to format ADSB Beast frames from bytes.
/// Expected input is a &Vec<Vec<u8>>of the beast frame(s), including the control characters to start and end the frame.
/// Does not consume the input.
/// Returns a vector of bytes, with each element of the array being a frame that can be passed in to the ADSB Beast parser.

#[must_use]
// FIXME: Can/should this be refactored in to less lines?
#[allow(clippy::too_many_lines)]
pub fn format_adsb_beast_frames_from_bytes(bytes: &[u8]) -> ADSBBeastFrames {
    let mut formatted_frames: Vec<Vec<u8>> = Vec::new();
    let mut leftbytes: Vec<u8> = Vec::new();
    let mut frame_type: FrameType = FrameType::None;
    let mut frame_bytes: Vec<u8> = Vec::new();
    let mut errors: Vec<ADSBBeastError> = Vec::new();

    // https://github.com/junzis/pyModeS/blob/77273153cba6c2f282f672ea4078a62efcf716d7/pyModeS/extra/tcpclient.py#L65
    // example logic for iterating over this buffer

    let mut byte_iter = bytes.iter().peekable();

    // loop through the bytes finding all frames
    while let Some(byte) = byte_iter.next() {
        let next_byte = byte_iter.peek();

        // if this is the start of a new frame, lets process the old one
        if (*byte == ADSB_BEAST_START_CHARACTER && next_byte != Some(&&ADSB_BEAST_START_CHARACTER))
            || next_byte.is_none()
        {
            // if this is the last byte, append it and then test
            if next_byte.is_none() {
                frame_bytes.push(*byte);
            }
            // if we have a frame, process it
            if !frame_bytes.is_empty() {
                // verify we have a valid frame length
                match frame_type {
                    FrameType::Short => {
                        if frame_bytes.len() == ADSB_BEAST_SHORT_FRAME_LENGTH {
                            formatted_frames.push(frame_bytes.clone());
                            frame_bytes.clear();
                        } else if next_byte.is_some() {
                            errors.push(ADSBBeastError::ShortFrameTooShort {
                                message: frame_bytes.len(),
                            });
                            frame_bytes.clear();
                        }
                    }
                    FrameType::Long => {
                        if frame_bytes.len() == ADSB_BEAST_LONG_FRAME_LENGTH {
                            formatted_frames.push(frame_bytes.clone());
                            frame_bytes.clear();
                        } else if next_byte.is_some() {
                            errors.push(ADSBBeastError::LongFrameTooShort {
                                message: frame_bytes.len(),
                            });
                            frame_bytes.clear();
                        }
                    }
                    FrameType::None => {
                        frame_bytes.clear();
                    }
                    FrameType::ModeAC => {
                        if frame_bytes.len() == ADSB_BEAST_MODEAC_FRAME_LENGTH {
                            // Ignore the modeac frame
                            frame_bytes.clear();
                        } else if next_byte.is_some() {
                            errors.push(ADSBBeastError::ModeACFrameTooShort {
                                message: frame_bytes.len(),
                            });
                            frame_bytes.clear();
                        }
                    }
                }
            }

            // determine the frame type
            match next_byte {
                Some(&&ADSB_BEAST_SHORT_FRAME_START_CHARACTER) => {
                    frame_type = FrameType::Short;
                    continue;
                }
                Some(&&ADSB_BEAST_LONG_FRAME_START_CHARACTER) => {
                    frame_type = FrameType::Long;
                    continue;
                }
                Some(&&ADSB_BEAST_MODEAC_FRAME_START_CHARACTER) => {
                    frame_type = FrameType::ModeAC;
                    continue;
                }
                None => {
                    // we are at the end of the buffer, continue to exit
                    continue;
                }
                _ => {
                    errors.push(ADSBBeastError::StartSequenceError {
                        message: format!("{byte:02X?}"),
                    });
                    frame_type = FrameType::None;
                    continue;
                }
            }
        }
        // if we have a valid frame type, we should continue, otherwise, we continue

        match frame_type {
            FrameType::None => {
                errors.push(ADSBBeastError::FrameTypeNone);
                continue;
            }
            _ => match *byte {
                ADSB_BEAST_START_CHARACTER => {
                    if next_byte == Some(&&ADSB_BEAST_START_CHARACTER) {
                        frame_bytes.push(*byte);
                        _ = byte_iter.next();
                        continue;
                    }

                    errors.push(ADSBBeastError::StartSequenceError {
                        message: format!("{byte:02X?}"),
                    });
                    frame_type = FrameType::None;
                    continue;
                }
                _ => {
                    frame_bytes.push(*byte);
                }
            },
        }
    }

    // We are done looping through the frame.
    // see if frame_bytes contains a valid frame
    // if it does, add it to the list of frames
    // otherwise, it's leftover bytes we'll process further down
    if !frame_bytes.is_empty() {
        // verify we have a valid frame length
        match frame_type {
            FrameType::Short => {
                if frame_bytes.len() == ADSB_BEAST_SHORT_FRAME_LENGTH {
                    formatted_frames.push(frame_bytes.clone());
                    frame_bytes.clear();
                }
            }
            FrameType::Long => {
                if frame_bytes.len() == ADSB_BEAST_LONG_FRAME_LENGTH {
                    formatted_frames.push(frame_bytes.clone());
                    frame_bytes.clear();
                }
            }
            FrameType::None => (),
            FrameType::ModeAC => {
                if frame_bytes.len() == ADSB_BEAST_MODEAC_FRAME_LENGTH {
                    // Ignore the modeac frame
                    frame_bytes.clear();
                }
            }
        }
    }

    // Process the leftover bytes
    // We need to cover off any 1a characters that are not part of a start sequence
    // as well as, if the frame starts with a start character, we need to add it back
    if !frame_bytes.is_empty() {
        // we trimmed off the control characters, so we need to add them back if the frame starts with a start character
        if let Some(
            &ADSB_BEAST_SHORT_FRAME_START_CHARACTER
            | &ADSB_BEAST_LONG_FRAME_START_CHARACTER
            | &ADSB_BEAST_MODEAC_FRAME_START_CHARACTER,
        ) = frame_bytes.first()
        {
            frame_bytes.insert(0, ADSB_BEAST_START_CHARACTER);
        } else {
            error!("Frame bytes is not empty, but the first byte is not a start character");
            error!("The frame bytes are: {:02X?}", frame_bytes);
        }

        // now walk the frame and replace any 1a with 1a 1a if it's not a 1a 31 or 1a 32 or 1a 33 sequence

        let mut new_frame_bytes: Vec<u8> = Vec::new();
        let mut byte_iter = frame_bytes.iter().peekable();
        while let Some(byte) = byte_iter.next() {
            let next_byte = byte_iter.peek();
            if *byte == ADSB_BEAST_START_CHARACTER
                && next_byte != Some(&&ADSB_BEAST_START_CHARACTER)
            {
                if next_byte.is_some() {
                    // TODO: does this pattern make sense? Can we combine this with the logic check
                    // above or destructure in to a match?
                    let Some(next_byte) = next_byte else {
                        error!("You should never see this!! Next byte is none but is_some returned true?");
                        break;
                    };

                    if **next_byte == ADSB_BEAST_MODEAC_FRAME_START_CHARACTER
                        || **next_byte == ADSB_BEAST_SHORT_FRAME_START_CHARACTER
                        || **next_byte == ADSB_BEAST_LONG_FRAME_START_CHARACTER
                    {
                        new_frame_bytes.push(*byte);
                    } else {
                        new_frame_bytes.push(*byte);
                        new_frame_bytes.push(*byte);
                    }
                } else {
                    new_frame_bytes.push(*byte);
                }
            } else {
                new_frame_bytes.push(*byte);
            }
        }
        leftbytes = new_frame_bytes;
    }

    ADSBBeastFrames {
        frames: formatted_frames,
        left_over: leftbytes,
        errors,
    }
}

#[cfg(test)]
mod tests {
    use sdre_rust_logging::SetupLogging;

    use super::*;

    #[test]
    fn test_adsb_beast_parsing_input() {
        "debug".enable_logging();

        // there are 33 frames in this input. 5 of the are MODEAC frames, which we don't want to decode
        let raw_frames = [
            0x1a as u8, 0x31, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x31, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x31, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x1a, 0x31, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x31, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x68, 0x61, 0x57, 0x19,
            0x2, 0xe1, 0x94, 0x10, 0xfa, 0xf5, 0x48, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x68, 0x8c, 0x89,
            0x12, 0x8d, 0xa7, 0xc3, 0x36, 0xea, 0x54, 0x18, 0x60, 0x1, 0x5f, 0x48, 0x8a, 0x91,
            0xd7, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x68, 0xe7, 0xd0, 0x2a, 0x2, 0xe1, 0x93, 0x38, 0xd4,
            0x59, 0x4f, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x69, 0x9, 0xe9, 0x40, 0x2, 0x0, 0x5, 0xbc,
            0xcf, 0x8d, 0x9a, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x69, 0x70, 0x57, 0x18, 0x8d, 0xac,
            0xb1, 0x8a, 0x58, 0xbf, 0x3, 0x94, 0xf5, 0x24, 0xc7, 0x72, 0x74, 0xe5, 0x1a, 0x32, 0x0,
            0x3e, 0x95, 0x69, 0x96, 0x6e, 0x20, 0x5d, 0xa7, 0xad, 0x84, 0x6c, 0x8f, 0xa, 0x1a,
            0x33, 0x0, 0x3e, 0x95, 0x69, 0xbd, 0x69, 0x18, 0x8d, 0xa4, 0x6f, 0x75, 0x99, 0x15,
            0x3a, 0x93, 0xb0, 0x8, 0x6, 0x79, 0xec, 0x70, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x69, 0xe4,
            0x11, 0x10, 0x5d, 0xa5, 0x59, 0x7b, 0xee, 0x11, 0x36, 0x1a, 0x32, 0x0, 0x3e, 0x95,
            0x6a, 0x23, 0x7e, 0x3d, 0x20, 0x0, 0x17, 0x18, 0xe7, 0x9e, 0x68, 0x1a, 0x32, 0x0, 0x3e,
            0x95, 0x6a, 0x42, 0x94, 0xf, 0x5d, 0xa5, 0x59, 0x7b, 0xee, 0x11, 0x37, 0x1a, 0x32, 0x0,
            0x3e, 0x95, 0x6a, 0x46, 0xc7, 0x11, 0x2, 0xe1, 0x90, 0xb8, 0xc0, 0x5c, 0x65, 0x1a,
            0x32, 0x0, 0x3e, 0x95, 0x6a, 0x66, 0x1, 0x30, 0x2, 0x0, 0x4, 0xbf, 0x36, 0x2c, 0xc8,
            0x1a, 0x33, 0x0, 0x3e, 0x95, 0x6b, 0x6, 0x43, 0xd, 0x8d, 0xa4, 0xfa, 0x78, 0xea, 0x4c,
            0x48, 0x5c, 0xed, 0x5c, 0x8, 0x61, 0x9f, 0x73, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x6b, 0x12,
            0x7e, 0xd4, 0x8d, 0xa0, 0x62, 0xef, 0x99, 0x9, 0xf1, 0x1a, 0x1a, 0x90, 0x4, 0x11, 0x3d,
            0xb8, 0x17, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x6b, 0x2a, 0x3d, 0x16, 0x8d, 0xa7, 0xd6,
            0xa8, 0x99, 0x15, 0x86, 0x86, 0xb8, 0x4, 0x13, 0x71, 0xd2, 0x9, 0x1a, 0x32, 0x0, 0x3e,
            0x95, 0x6b, 0x55, 0x75, 0x3e, 0x5d, 0xa1, 0x25, 0x95, 0x36, 0x1e, 0x78, 0x1a, 0x33,
            0x0, 0x3e, 0x95, 0x6b, 0x80, 0x8b, 0xd, 0x8f, 0xa6, 0x27, 0x4a, 0xe1, 0x10, 0x98, 0x0,
            0x0, 0x0, 0x0, 0x94, 0xb2, 0x49, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x6b, 0xd1, 0x12, 0x15,
            0x2, 0x0, 0x4, 0x97, 0x3e, 0x1f, 0xe6, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x6c, 0x4a, 0xd9,
            0x10, 0x8d, 0xac, 0x15, 0x47, 0x58, 0xb9, 0x80, 0xb8, 0x9b, 0x86, 0xae, 0xaf, 0xaa,
            0xd, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x6d, 0x5, 0x46, 0xe, 0x2, 0xe1, 0x9c, 0xb0, 0x8a,
            0xf6, 0x4f, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x6e, 0xc, 0xce, 0x43, 0x5d, 0xa1, 0x25, 0x95,
            0x36, 0x1e, 0x78, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x6e, 0x8d, 0x2c, 0xf, 0x5d, 0xa5, 0x59,
            0x7b, 0xee, 0x11, 0x36, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x6e, 0xa0, 0xda, 0x33, 0x2, 0xe1,
            0x97, 0x18, 0xe0, 0xfd, 0xc8, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x6e, 0xa9, 0xac, 0xa2,
            0x8d, 0xa4, 0x45, 0x85, 0x99, 0x9, 0xdd, 0x1a, 0x1a, 0xf8, 0x4, 0xe, 0xde, 0x3, 0x2,
            0x1a, 0x33, 0x0, 0x3e, 0x95, 0x6e, 0xb6, 0xaa, 0x1d, 0x8d, 0xa7, 0xe2, 0xda, 0x99, 0xd,
            0x86, 0x7, 0x0, 0x4, 0x16, 0xca, 0x83, 0x69, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x6e, 0xcf,
            0xb8, 0x20, 0x0, 0x0, 0x12, 0x0, 0x5e, 0x95, 0x74, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x6e,
            0xf2, 0xf, 0x15, 0x2, 0x0, 0x4, 0x97, 0x3e, 0x1f, 0xe6, 0x1a, 0x32, 0x0, 0x3e, 0x95,
            0x6f, 0x49, 0x85, 0x41, 0x2, 0x5, 0x85, 0xbc, 0xc, 0x18, 0xfb, 0x1a, 0x33, 0x0, 0x3e,
            0x95, 0x6f, 0xae, 0x75, 0x25, 0x8d, 0xa1, 0x78, 0xde, 0x99, 0xd, 0x40, 0x9f, 0x10, 0x8,
            0xe, 0x84, 0x5, 0xe8, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x70, 0x5, 0xcc, 0x55, 0x8d, 0xad,
            0xd3, 0x76, 0x58, 0xab, 0x17, 0x7c, 0xab, 0xea, 0x6d, 0x7a, 0x9f, 0x5f, 0x1a, 0x32,
            0x0, 0x3e, 0x95, 0x70, 0x48, 0x90, 0x11, 0x5d, 0xa4, 0x41, 0x87, 0x76, 0x9d, 0xe4,
            0x1a, 0x32, 0x0, 0x3e, 0x95, 0x70, 0x82, 0x77, 0x2e, 0x2, 0xe1, 0x95, 0x31, 0xb, 0xa2,
            0x6d, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x70, 0x9f, 0x31, 0x62, 0x8d, 0xa5, 0x5, 0xfe, 0xe1,
            0xa, 0x4, 0x0, 0x0, 0x0, 0x0, 0x11, 0xac, 0x6c, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x70,
            0xae, 0x9c, 0x5a, 0x8d, 0xc0, 0x1e, 0x11, 0x99, 0x10, 0x5a, 0xb7, 0xf8, 0x4, 0x10,
            0x36, 0xf7, 0x67, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x71, 0x20, 0x67, 0x2b, 0x8d, 0xad,
            0x15, 0x60, 0x99, 0xa, 0xd, 0x4, 0x18, 0x4, 0xa, 0xe4, 0xfc, 0x20, 0x1a, 0x33, 0x0,
            0x3e, 0x95, 0x71, 0xdd, 0xb, 0xf, 0x8d, 0xc0, 0x1, 0xed, 0x99, 0x15, 0x40, 0x2, 0x90,
            0x4, 0x1f, 0x7d, 0xce, 0xe9, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x71, 0xe6, 0x1c, 0x22, 0x2,
            0xe1, 0x92, 0x19, 0x21, 0xcd, 0x85, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x71, 0xfa, 0x9a,
            0x3c, 0x8d, 0xa1, 0x25, 0x95, 0xe1, 0xe, 0x4, 0x0, 0x0, 0x0, 0x0, 0x86, 0xce, 0x8e,
        ];

        let frames = format_adsb_beast_frames_from_bytes(&raw_frames);
        for frame in frames.frames.iter() {
            info!("Frame: {:02X?}", frame);
        }
        assert!(
            frames.frames.len() == 38,
            "Expected 38 frames, got {}",
            frames.frames.len()
        );

        // validate each frame is the correct length
        for frame in frames.frames.iter() {
            assert!(
                frame.len() == ADSB_BEAST_SHORT_FRAME_LENGTH
                    || frame.len() == ADSB_BEAST_LONG_FRAME_LENGTH,
                "Frame is not the correct length: {}",
                frame.len()
            );
        }

        // validate the leftover bytes are correct
        assert!(
            frames.left_over.len() == 0,
            "Expected 0 leftover bytes, got {}",
            frames.left_over.len()
        );
    }

    #[test]
    fn test_extra_bytes_in_input() {
        "debug".enable_logging();

        // there are 33 frames in this input. 5 of the are MODEAC frames, which we don't want to decode
        let raw_frames = [
            0x1a as u8, 0x31, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x31, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x31, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x1a, 0x31, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x31, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x68, 0x61, 0x57, 0x19,
            0x2, 0xe1, 0x94, 0x10, 0xfa, 0xf5, 0x48, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x68, 0x8c, 0x89,
            0x12, 0x8d, 0xa7, 0xc3, 0x36, 0xea, 0x54, 0x18, 0x60, 0x1, 0x5f, 0x48, 0x8a, 0x91,
            0xd7, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x68, 0xe7, 0xd0, 0x2a, 0x2, 0xe1, 0x93, 0x38, 0xd4,
            0x59, 0x4f, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x69, 0x9, 0xe9, 0x40, 0x2, 0x0, 0x5, 0xbc,
            0xcf, 0x8d, 0x9a, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x69, 0x70, 0x57, 0x18, 0x8d, 0xac,
            0xb1, 0x8a, 0x58, 0xbf, 0x3, 0x94, 0xf5, 0x24, 0xc7, 0x72, 0x74, 0xe5, 0x1a, 0x32, 0x0,
            0x3e, 0x95, 0x69, 0x96, 0x6e, 0x20, 0x5d, 0xa7, 0xad, 0x84, 0x6c, 0x8f, 0xa, 0x1a,
            0x33, 0x0, 0x3e, 0x95, 0x69, 0xbd, 0x69, 0x18, 0x8d, 0xa4, 0x6f, 0x75, 0x99, 0x15,
            0x3a, 0x93, 0xb0, 0x8, 0x6, 0x79, 0xec, 0x70, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x69, 0xe4,
            0x11, 0x10, 0x5d, 0xa5, 0x59, 0x7b, 0xee, 0x11, 0x36, 0x1a, 0x32, 0x0, 0x3e, 0x95,
            0x6a, 0x23, 0x7e, 0x3d, 0x20, 0x0, 0x17, 0x18, 0xe7, 0x9e, 0x68, 0x1a, 0x32, 0x0, 0x3e,
            0x95, 0x6a, 0x42, 0x94, 0xf, 0x5d, 0xa5, 0x59, 0x7b, 0xee, 0x11, 0x37, 0x1a, 0x32, 0x0,
            0x3e, 0x95, 0x6a, 0x46, 0xc7, 0x11, 0x2, 0xe1, 0x90, 0xb8, 0xc0, 0x5c, 0x65, 0x1a,
            0x32, 0x0, 0x3e, 0x95, 0x6a, 0x66, 0x1, 0x30, 0x2, 0x0, 0x4, 0xbf, 0x36, 0x2c, 0xc8,
            0x1a, 0x33, 0x0, 0x3e, 0x95, 0x6b, 0x6, 0x43, 0xd, 0x8d, 0xa4, 0xfa, 0x78, 0xea, 0x4c,
            0x48, 0x5c, 0xed, 0x5c, 0x8, 0x61, 0x9f, 0x73, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x6b, 0x12,
            0x7e, 0xd4, 0x8d, 0xa0, 0x62, 0xef, 0x99, 0x9, 0xf1, 0x1a, 0x1a, 0x90, 0x4, 0x11, 0x3d,
            0xb8, 0x17, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x6b, 0x2a, 0x3d, 0x16, 0x8d, 0xa7, 0xd6,
            0xa8, 0x99, 0x15, 0x86, 0x86, 0xb8, 0x4, 0x13, 0x71, 0xd2, 0x9, 0x1a, 0x32, 0x0, 0x3e,
            0x95, 0x6b, 0x55, 0x75, 0x3e, 0x5d, 0xa1, 0x25, 0x95, 0x36, 0x1e, 0x78, 0x1a, 0x33,
            0x0, 0x3e, 0x95, 0x6b, 0x80, 0x8b, 0xd, 0x8f, 0xa6, 0x27, 0x4a, 0xe1, 0x10, 0x98, 0x0,
            0x0, 0x0, 0x0, 0x94, 0xb2, 0x49, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x6b, 0xd1, 0x12, 0x15,
            0x2, 0x0, 0x4, 0x97, 0x3e, 0x1f, 0xe6, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x6c, 0x4a, 0xd9,
            0x10, 0x8d, 0xac, 0x15, 0x47, 0x58, 0xb9, 0x80, 0xb8, 0x9b, 0x86, 0xae, 0xaf, 0xaa,
            0xd, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x6d, 0x5, 0x46, 0xe, 0x2, 0xe1, 0x9c, 0xb0, 0x8a,
            0xf6, 0x4f, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x6e, 0xc, 0xce, 0x43, 0x5d, 0xa1, 0x25, 0x95,
            0x36, 0x1e, 0x78, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x6e, 0x8d, 0x2c, 0xf, 0x5d, 0xa5, 0x59,
            0x7b, 0xee, 0x11, 0x36, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x6e, 0xa0, 0xda, 0x33, 0x2, 0xe1,
            0x97, 0x18, 0xe0, 0xfd, 0xc8, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x6e, 0xa9, 0xac, 0xa2,
            0x8d, 0xa4, 0x45, 0x85, 0x99, 0x9, 0xdd, 0x1a, 0x1a, 0xf8, 0x4, 0xe, 0xde, 0x3, 0x2,
            0x1a, 0x33, 0x0, 0x3e, 0x95, 0x6e, 0xb6, 0xaa, 0x1d, 0x8d, 0xa7, 0xe2, 0xda, 0x99, 0xd,
            0x86, 0x7, 0x0, 0x4, 0x16, 0xca, 0x83, 0x69, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x6e, 0xcf,
            0xb8, 0x20, 0x0, 0x0, 0x12, 0x0, 0x5e, 0x95, 0x74, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x6e,
            0xf2, 0xf, 0x15, 0x2, 0x0, 0x4, 0x97, 0x3e, 0x1f, 0xe6, 0x1a, 0x32, 0x0, 0x3e, 0x95,
            0x6f, 0x49, 0x85, 0x41, 0x2, 0x5, 0x85, 0xbc, 0xc, 0x18, 0xfb, 0x1a, 0x33, 0x0, 0x3e,
            0x95, 0x6f, 0xae, 0x75, 0x25, 0x8d, 0xa1, 0x78, 0xde, 0x99, 0xd, 0x40, 0x9f, 0x10, 0x8,
            0xe, 0x84, 0x5, 0xe8, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x70, 0x5, 0xcc, 0x55, 0x8d, 0xad,
            0xd3, 0x76, 0x58, 0xab, 0x17, 0x7c, 0xab, 0xea, 0x6d, 0x7a, 0x9f, 0x5f, 0x1a, 0x32,
            0x0, 0x3e, 0x95, 0x70, 0x48, 0x90, 0x11, 0x5d, 0xa4, 0x41, 0x87, 0x76, 0x9d, 0xe4,
            0x1a, 0x32, 0x0, 0x3e, 0x95, 0x70, 0x82, 0x77, 0x2e, 0x2, 0xe1, 0x95, 0x31, 0xb, 0xa2,
            0x6d, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x70, 0x9f, 0x31, 0x62, 0x8d, 0xa5, 0x5, 0xfe, 0xe1,
            0xa, 0x4, 0x0, 0x0, 0x0, 0x0, 0x11, 0xac, 0x6c, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x70,
            0xae, 0x9c, 0x5a, 0x8d, 0xc0, 0x1e, 0x11, 0x99, 0x10, 0x5a, 0xb7, 0xf8, 0x4, 0x10,
            0x36, 0xf7, 0x67, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x71, 0x20, 0x67, 0x2b, 0x8d, 0xad,
            0x15, 0x60, 0x99, 0xa, 0xd, 0x4, 0x18, 0x4, 0xa, 0xe4, 0xfc, 0x20, 0x1a, 0x33, 0x0,
            0x3e, 0x95, 0x71, 0xdd, 0xb, 0xf, 0x8d, 0xc0, 0x1, 0xed, 0x99, 0x15, 0x40, 0x2, 0x90,
            0x4, 0x1f, 0x7d, 0xce, 0xe9, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x71, 0xe6, 0x1c, 0x22, 0x2,
            0xe1, 0x92, 0x19, 0x21, 0xcd, 0x85, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x71, 0xfa, 0x9a,
            0x3c, 0x8d, 0xa1, 0x25, 0x95, 0xe1, 0xe, 0x4, 0x0, 0x0, 0x0, 0x0, 0x86, 0xce, 0x8e,
        ];

        let frames = format_adsb_beast_frames_from_bytes(&raw_frames);
        for frame in frames.frames.iter() {
            info!("Frame: {:02X?}", frame);
        }
        assert!(
            frames.frames.len() == 38,
            "Expected 38 frames, got {}",
            frames.frames.len()
        );

        // validate each frame is the correct length
        for frame in frames.frames.iter() {
            assert!(
                frame.len() == ADSB_BEAST_SHORT_FRAME_LENGTH
                    || frame.len() == ADSB_BEAST_LONG_FRAME_LENGTH,
                "Frame is not the correct length: {}",
                frame.len()
            );
        }

        // validate the leftover bytes are correct
        assert!(
            frames.left_over.len() == 0,
            "Expected 0 leftover bytes, got {}",
            frames.left_over.len()
        );
    }

    #[test]
    fn test_extra_bytes_at_end_input() {
        "debug".enable_logging();

        // there are 33 frames in this input. 5 of the are MODEAC frames, which we don't want to decode
        let raw_frames = [
            0x1a as u8, 0x31, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x31, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x31, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x1a, 0x31, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x31, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x68, 0x61, 0x57, 0x19,
            0x2, 0xe1, 0x94, 0x10, 0xfa, 0xf5, 0x48, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x68, 0x8c, 0x89,
            0x12, 0x8d, 0xa7, 0xc3, 0x36, 0xea, 0x54, 0x18, 0x60, 0x1, 0x5f, 0x48, 0x8a, 0x91,
            0xd7, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x68, 0xe7, 0xd0, 0x2a, 0x2, 0xe1, 0x93, 0x38, 0xd4,
            0x59, 0x4f, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x69, 0x9, 0xe9, 0x40, 0x2, 0x0, 0x5, 0xbc,
            0xcf, 0x8d, 0x9a, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x69, 0x70, 0x57, 0x18, 0x8d, 0xac,
            0xb1, 0x8a, 0x58, 0xbf, 0x3, 0x94, 0xf5, 0x24, 0xc7, 0x72, 0x74, 0xe5, 0x1a, 0x32, 0x0,
            0x3e, 0x95, 0x69, 0x96, 0x6e, 0x20, 0x5d, 0xa7, 0xad, 0x84, 0x6c, 0x8f, 0xa, 0x1a,
            0x33, 0x0, 0x3e, 0x95, 0x69, 0xbd, 0x69, 0x18, 0x8d, 0xa4, 0x6f, 0x75, 0x99, 0x15,
            0x3a, 0x93, 0xb0, 0x8, 0x6, 0x79, 0xec, 0x70, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x69, 0xe4,
            0x11, 0x10, 0x5d, 0xa5, 0x59, 0x7b, 0xee, 0x11, 0x36, 0x1a, 0x32, 0x0, 0x3e, 0x95,
            0x6a, 0x23, 0x7e, 0x3d, 0x20, 0x0, 0x17, 0x18, 0xe7, 0x9e, 0x68, 0x1a, 0x32, 0x0, 0x3e,
            0x95, 0x6a, 0x42, 0x94, 0xf, 0x5d, 0xa5, 0x59, 0x7b, 0xee, 0x11, 0x37, 0x1a, 0x32, 0x0,
            0x3e, 0x95, 0x6a, 0x46, 0xc7, 0x11, 0x2, 0xe1, 0x90, 0xb8, 0xc0, 0x5c, 0x65, 0x1a,
            0x32, 0x0, 0x3e, 0x95, 0x6a, 0x66, 0x1, 0x30, 0x2, 0x0, 0x4, 0xbf, 0x36, 0x2c, 0xc8,
            0x1a, 0x33, 0x0, 0x3e, 0x95, 0x6b, 0x6, 0x43, 0xd, 0x8d, 0xa4, 0xfa, 0x78, 0xea, 0x4c,
            0x48, 0x5c, 0xed, 0x5c, 0x8, 0x61, 0x9f, 0x73, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x6b, 0x12,
            0x7e, 0xd4, 0x8d, 0xa0, 0x62, 0xef, 0x99, 0x9, 0xf1, 0x1a, 0x1a, 0x90, 0x4, 0x11, 0x3d,
            0xb8, 0x17, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x6b, 0x2a, 0x3d, 0x16, 0x8d, 0xa7, 0xd6,
            0xa8, 0x99, 0x15, 0x86, 0x86, 0xb8, 0x4, 0x13, 0x71, 0xd2, 0x9, 0x1a, 0x32, 0x0, 0x3e,
            0x95, 0x6b, 0x55, 0x75, 0x3e, 0x5d, 0xa1, 0x25, 0x95, 0x36, 0x1e, 0x78, 0x1a, 0x33,
            0x0, 0x3e, 0x95, 0x6b, 0x80, 0x8b, 0xd, 0x8f, 0xa6, 0x27, 0x4a, 0xe1, 0x10, 0x98, 0x0,
            0x0, 0x0, 0x0, 0x94, 0xb2, 0x49, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x6b, 0xd1, 0x12, 0x15,
            0x2, 0x0, 0x4, 0x97, 0x3e, 0x1f, 0xe6, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x6c, 0x4a, 0xd9,
            0x10, 0x8d, 0xac, 0x15, 0x47, 0x58, 0xb9, 0x80, 0xb8, 0x9b, 0x86, 0xae, 0xaf, 0xaa,
            0xd, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x6d, 0x5, 0x46, 0xe, 0x2, 0xe1, 0x9c, 0xb0, 0x8a,
            0xf6, 0x4f, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x6e, 0xc, 0xce, 0x43, 0x5d, 0xa1, 0x25, 0x95,
            0x36, 0x1e, 0x78, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x6e, 0x8d, 0x2c, 0xf, 0x5d, 0xa5, 0x59,
            0x7b, 0xee, 0x11, 0x36, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x6e, 0xa0, 0xda, 0x33, 0x2, 0xe1,
            0x97, 0x18, 0xe0, 0xfd, 0xc8, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x6e, 0xa9, 0xac, 0xa2,
            0x8d, 0xa4, 0x45, 0x85, 0x99, 0x9, 0xdd, 0x1a, 0x1a, 0xf8, 0x4, 0xe, 0xde, 0x3, 0x2,
            0x1a, 0x33, 0x0, 0x3e, 0x95, 0x6e, 0xb6, 0xaa, 0x1d, 0x8d, 0xa7, 0xe2, 0xda, 0x99, 0xd,
            0x86, 0x7, 0x0, 0x4, 0x16, 0xca, 0x83, 0x69, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x6e, 0xcf,
            0xb8, 0x20, 0x0, 0x0, 0x12, 0x0, 0x5e, 0x95, 0x74, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x6e,
            0xf2, 0xf, 0x15, 0x2, 0x0, 0x4, 0x97, 0x3e, 0x1f, 0xe6, 0x1a, 0x32, 0x0, 0x3e, 0x95,
            0x6f, 0x49, 0x85, 0x41, 0x2, 0x5, 0x85, 0xbc, 0xc, 0x18, 0xfb, 0x1a, 0x33, 0x0, 0x3e,
            0x95, 0x6f, 0xae, 0x75, 0x25, 0x8d, 0xa1, 0x78, 0xde, 0x99, 0xd, 0x40, 0x9f, 0x10, 0x8,
            0xe, 0x84, 0x5, 0xe8, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x70, 0x5, 0xcc, 0x55, 0x8d, 0xad,
            0xd3, 0x76, 0x58, 0xab, 0x17, 0x7c, 0xab, 0xea, 0x6d, 0x7a, 0x9f, 0x5f, 0x1a, 0x32,
            0x0, 0x3e, 0x95, 0x70, 0x48, 0x90, 0x11, 0x5d, 0xa4, 0x41, 0x87, 0x76, 0x9d, 0xe4,
            0x1a, 0x32, 0x0, 0x3e, 0x95, 0x70, 0x82, 0x77, 0x2e, 0x2, 0xe1, 0x95, 0x31, 0xb, 0xa2,
            0x6d, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x70, 0x9f, 0x31, 0x62, 0x8d, 0xa5, 0x5, 0xfe, 0xe1,
            0xa, 0x4, 0x0, 0x0, 0x0, 0x0, 0x11, 0xac, 0x6c, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x70,
            0xae, 0x9c, 0x5a, 0x8d, 0xc0, 0x1e, 0x11, 0x99, 0x10, 0x5a, 0xb7, 0xf8, 0x4, 0x10,
            0x36, 0xf7, 0x67, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x71, 0x20, 0x67, 0x2b, 0x8d, 0xad,
            0x15, 0x60, 0x99, 0xa, 0xd, 0x4, 0x18, 0x4, 0xa, 0xe4, 0xfc, 0x20, 0x1a, 0x33, 0x0,
            0x3e, 0x95, 0x71, 0xdd, 0xb, 0xf, 0x8d, 0xc0, 0x1, 0xed, 0x99, 0x15, 0x40, 0x2, 0x90,
            0x4, 0x1f, 0x7d, 0xce, 0xe9, 0x1a, 0x32, 0x0, 0x3e, 0x95, 0x71, 0xe6, 0x1c, 0x22, 0x2,
            0xe1, 0x92, 0x19, 0x21, 0xcd, 0x85, 0x1a, 0x33, 0x0, 0x3e, 0x95, 0x71, 0xfa, 0x9a,
            0x3c, 0x8d, 0xa1, 0x25, 0x95, 0xe1, 0xe, 0x4, 0x0, 0x0, 0x0, 0x0, 0x86, 0xce, 0x8e,
            0x1a, 0x33,
        ];

        let frames = format_adsb_beast_frames_from_bytes(&raw_frames);
        for frame in frames.frames.iter() {
            info!("Frame: {:02X?}", frame);
        }
        assert!(
            frames.frames.len() == 38,
            "Expected 38 frames, got {}",
            frames.frames.len()
        );

        // validate each frame is the correct length
        for frame in frames.frames.iter() {
            assert!(
                frame.len() == ADSB_BEAST_SHORT_FRAME_LENGTH
                    || frame.len() == ADSB_BEAST_LONG_FRAME_LENGTH,
                "Frame is not the correct length: {}",
                frame.len()
            );
        }

        // validate the leftover bytes are correct
        assert!(
            frames.left_over.len() == 2,
            "Expected 2 leftover bytes, got {}",
            frames.left_over.len()
        );
    }

    #[test]
    fn test_buffer_left_over_reassembly() {
        "debug".enable_logging();

        let raw_frames = [
            0x1A as u8, 0x33, 0x01, 0x9B, 0x52, 0x68, 0xF7, 0xAE, 0x2F, 0x8D, 0xA6, 0x1F, 0x0E,
            0x99, 0x15, 0x31, 0x19, 0xB0, 0x04, 0x13, 0x2C, 0xE9, 0xFC, 0x1A, 0x32, 0x01, 0x9B,
            0x52, 0x69, 0x1A, 0x1A, 0xE3, 0xB3, 0x02, 0x00, 0x03, 0xA0,
        ];

        let frames = format_adsb_beast_frames_from_bytes(&raw_frames);

        assert!(
            frames.frames.len() == 1,
            "Expected 1 frame, got {}",
            frames.frames.len()
        );
        assert!(
            frames.left_over.len() == 14,
            "Expected 14 leftover bytes, got {}",
            frames.left_over.len(),
        );

        let raw_frames = [
            0xE3 as u8, 0x60, 0x2B, 0x1A, 0x33, 0x01, 0x9B, 0x52, 0x69, 0x9D, 0xE5, 0x64, 0x8D,
            0xA1, 0x35, 0x01, 0x99, 0x0D, 0x5C, 0x16, 0x10, 0x04, 0x1B, 0x6D, 0xD9, 0xCC, 0x1A,
            0x33, 0x01, 0x9B, 0x52, 0x69, 0xBB, 0xB6, 0x17, 0x8D, 0xA1, 0x31, 0x4E, 0x99, 0x09,
            0xF1, 0x00, 0x90, 0x04, 0x22, 0x42, 0xC9, 0x7B, 0x1A, 0x32, 0x01, 0x9B, 0x52, 0x6A,
            0x79, 0xF4, 0x1B, 0x02, 0x00, 0x04, 0x80, 0xC2, 0x60, 0x4C, 0x1A, 0x32, 0x01, 0x9B,
            0x52, 0x6A, 0x8A, 0x98, 0x0F, 0x02, 0xE1, 0x96, 0x3F, 0x7C, 0x91, 0xF3, 0x1A, 0x32,
            0x01, 0x9B, 0x52, 0x6A, 0xEF, 0x1C, 0x16, 0x02, 0xE1, 0x99, 0x11, 0x44, 0xC4, 0x23,
            0x1A, 0x32, 0x01, 0x9B, 0x52, 0x6B, 0x13, 0x39, 0x10, 0x02, 0xE1, 0x97, 0xB0, 0xEC,
            0xBC, 0x4B, 0x1A, 0x32, 0x01, 0x9B, 0x52, 0x6B, 0x6E, 0x5E, 0x0B, 0x02, 0xE1, 0x96,
            0x3D, 0x19, 0xAD, 0x63, 0x1A, 0x32, 0x01, 0x9B, 0x52, 0x6B, 0x9E, 0x68, 0x1E, 0x02,
            0xE1, 0x97, 0xB0, 0xE3, 0xA3, 0xE3, 0x1A, 0x32, 0x01, 0x9B, 0x52, 0x6B, 0xD6, 0xCE,
            0x19, 0x02, 0xE1, 0x97, 0xB0, 0xE1, 0x98, 0xE8, 0x1A, 0x32, 0x01, 0x9B, 0x52, 0x6C,
            0x10, 0xC3, 0x1D, 0x02, 0xE1, 0x99, 0x10, 0xBA, 0xA7, 0x91, 0x1A, 0x33, 0x01, 0x9B,
            0x52, 0x6C, 0x6C, 0x2D, 0x22, 0x8D, 0xA4, 0xAC, 0xF3, 0x99, 0x11, 0xBE, 0x07, 0x78,
            0x08, 0x1F, 0x64, 0xAE, 0x69, 0x1A, 0x33, 0x01, 0x9B, 0x52, 0x6C, 0xCB, 0xD8, 0x11,
            0x8D, 0xA6, 0x3F, 0x52, 0x59, 0xA5, 0xB3, 0xA2, 0xC7, 0x25, 0xB7, 0x43, 0xB8, 0x3F,
            0x1A, 0x32, 0x01, 0x9B, 0x52, 0x6D, 0x74, 0x3A, 0xCA, 0x5D, 0xAD, 0xE8, 0xAE, 0x52,
            0x9B, 0xD5, 0x1A, 0x33, 0x01, 0x9B, 0x52, 0x6D, 0xE0, 0x60, 0x8C, 0x8D, 0xA7, 0x7C,
            0x26, 0xE1, 0x0F, 0x99, 0x00, 0x00, 0x00, 0x00, 0xB1, 0xA1, 0x30, 0x1A, 0x33, 0x01,
            0x9B, 0x52, 0x6E, 0x6C, 0x1C, 0x22, 0x8D, 0xA4, 0xAC, 0xF3, 0x59, 0xD3, 0x04, 0x53,
            0xDE, 0x09, 0xE0, 0x25, 0x40, 0x0A, 0x1A, 0x32, 0x01, 0x9B, 0x52, 0x6F, 0x02, 0xC5,
            0x58, 0x20, 0x00, 0x16, 0x90, 0xE3, 0x61, 0x8E, 0x1A, 0x33, 0x01, 0x9B, 0x52, 0x6F,
            0x14, 0x82, 0x60, 0x8D, 0xAB, 0x81, 0x12, 0xEA, 0x0F, 0xB8, 0xC4, 0xE1, 0x3C, 0x08,
            0x03, 0x5D, 0xC7, 0x1A, 0x32, 0x01, 0x9B, 0x52, 0x6F, 0x64, 0xBB, 0x8C, 0x20, 0x00,
            0x1A, 0x1A, 0x32, 0xAA, 0x88, 0x0A, 0x1A, 0x32, 0x01, 0x9B, 0x52, 0x6F, 0x75, 0x79,
            0x15, 0x02, 0xE1, 0x9A, 0x30, 0xA3, 0x5A, 0x1C, 0x1A, 0x33, 0x01, 0x9B, 0x52, 0x6F,
            0x89, 0xE2, 0x72, 0x8D, 0xA4, 0x26, 0xA5, 0x99, 0x0D, 0x4D, 0xA2, 0x50, 0x04, 0x1F,
            0x7C, 0x3C, 0x37, 0x1A, 0x33, 0x01, 0x9B, 0x52, 0x6F, 0xB6, 0x96, 0x3D, 0x8D, 0xA3,
            0xC9, 0xC5, 0x58, 0xBF, 0x07, 0xC8, 0x38, 0x56, 0x6B, 0xAC, 0xC9, 0x35,
        ];

        // grab the leftover bytes and prepend them to the next buffer
        let raw_frame = [frames.left_over, raw_frames.to_vec()].concat();
        info!("using this frame: {:02X?}", raw_frame);
        let frames = format_adsb_beast_frames_from_bytes(&raw_frame);
        for frame in frames.frames.iter() {
            info!("Frame: {:02X?}", frame);
        }
        assert!(
            frames.frames.len() == 22,
            "Expected 22 frame, got {}",
            frames.frames.len()
        );
        assert!(
            frames.left_over.len() == 0,
            "Expected 0 leftover bytes, got {}",
            frames.left_over.len(),
        );
    }

    #[test]
    fn test_double_ends_in_message_and_end_of_frame() {
        "debug".enable_logging();

        let raw_frame = [
            0x1A as u8, 0x33, 0x01, 0xB5, 0xBF, 0x52, 0x0C, 0x77, 0x1D, 0x8D, 0xAB, 0x97, 0x40,
            0x59, 0x2F, 0x16, 0x98, 0xB5, 0x94, 0x6E, 0xDE, 0x10, 0x8E, 0x1A, 0x33, 0x01, 0xB5,
            0xBF, 0x52, 0x16, 0x16, 0x1B, 0x8D, 0xAB, 0x97, 0x40, 0x99, 0x14, 0x79, 0x03, 0x50,
            0x04, 0x09, 0x95, 0x7A, 0x18, 0x1A, 0x32, 0x01, 0xB5, 0xBF, 0x53, 0x9F, 0x89, 0x6D,
            0x5D, 0xA4, 0x4C, 0xFD, 0x32, 0x04, 0x1A, 0x1A, 0x1A, 0x33, 0x01, 0xB5, 0xBF, 0x53,
            0xD0, 0x8A, 0x4C, 0x8D, 0xA2, 0x03, 0xA9, 0x99, 0x11, 0xBE, 0x92, 0xF0, 0x08, 0x1D,
            0xD5, 0xDB, 0xB8, 0x1A, 0x33, 0x01, 0xB5, 0xBF, 0x54, 0x3D, 0xAB, 0x33, 0x8D, 0xAE,
            0x5D, 0x09, 0x99, 0x10, 0x05, 0x8C, 0x48, 0x10, 0x11, 0xA4, 0xCC, 0xDE, 0x1A, 0x33,
            0x01, 0xB5, 0xBF, 0x54, 0x5A, 0xCE, 0x27, 0x8D, 0xAC, 0x3E, 0x3A, 0x23, 0x4D, 0x70,
            0x75, 0xC3, 0x78, 0x20, 0xC0, 0xEB, 0xC1, 0x1A, 0x33, 0x01, 0xB5, 0xBF, 0x54, 0x7E,
            0xE4, 0x2F, 0x8D, 0xAA, 0x9B, 0x42, 0x99, 0x11, 0xEA, 0x04, 0x30, 0x04, 0x22, 0x91,
            0xF4, 0xE4, 0x1A, 0x32, 0x01, 0xB5, 0xBF, 0x55, 0x0E, 0xB1, 0x40, 0x02, 0xE1, 0x97,
            0xB1, 0x14, 0x88, 0x08, 0x1A, 0x32, 0x01, 0xB5, 0xBF, 0x55, 0xFD, 0xCB, 0xB3, 0x5D,
            0xA4, 0x45, 0xCD, 0x4D, 0x44, 0xF5, 0x1A, 0x32, 0x01, 0xB5, 0xBF, 0x56, 0x11, 0x62,
            0x20, 0x02, 0xE6, 0x17, 0x18, 0x3D, 0x3D, 0xC7, 0x1A, 0x33, 0x01, 0xB5, 0xBF, 0x56,
            0x66, 0x91, 0x11, 0x8D, 0xA0, 0x91, 0xFD, 0x58, 0xAF, 0x93, 0xC1, 0x30, 0xEB, 0xD4,
            0x0A, 0xD7, 0x93, 0x1A, 0x32, 0x01, 0xB5, 0xBF, 0x56, 0xDB, 0x09, 0x21, 0x02, 0xE6,
            0x17, 0x18, 0x3D, 0x3D, 0xC7, 0x1A, 0x32, 0x01, 0xB5, 0xBF, 0x57, 0x35, 0x4D, 0x6B,
            0x5D, 0xA4, 0x4C, 0xFD, 0x32, 0x04, 0x1A, 0x1A, 0x1A, 0x32, 0x01, 0xB5, 0xBF, 0x57,
            0x5A, 0x18, 0x2E, 0x5D, 0xA3, 0x3E, 0xDA, 0x53, 0x37, 0x52, 0x1A, 0x33, 0x01, 0xB5,
            0xBF, 0x57, 0x5C, 0xFF, 0x12, 0x8D, 0xAB, 0xE0, 0x56, 0x58, 0xBF, 0x07, 0x34, 0xF1,
            0x98, 0x0D, 0xC9, 0xEE, 0x54, 0x1A, 0x32, 0x01, 0xB5, 0xBF, 0x57, 0x68, 0xE5, 0x24,
            0x5D, 0xAC, 0xF0, 0xDA, 0xCD, 0x61, 0xAB, 0x1A, 0x32, 0x01, 0xB5, 0xBF, 0x57, 0xA7,
            0xFA, 0x20, 0x02, 0xE6, 0x17, 0x18, 0x3D, 0x3D, 0xC7, 0x1A, 0x32, 0x01, 0xB5, 0xBF,
            0x58, 0x25, 0x64, 0x11, 0x02, 0xE6, 0x15, 0xB9, 0xD1, 0x52, 0x46, 0x1A, 0x33, 0x01,
            0xB5, 0xBF, 0x58, 0x32, 0x33, 0x24, 0x8D, 0xAB, 0xD9, 0x4D, 0x58, 0xC3, 0x90, 0xC8,
            0xC4, 0x28, 0x66, 0xEE, 0xB7, 0xBC, 0x1A, 0x32, 0x01, 0xB5, 0xBF, 0x59, 0xEC, 0x5D,
            0x6D, 0x5D, 0xA4, 0x4C, 0xFD, 0x32, 0x04, 0x1A, 0x1A, 0x1A, 0x32, 0x01, 0xB5, 0xBF,
            0x5A, 0x11, 0x28, 0x2D, 0x5D, 0xA3, 0x3E, 0xDA, 0x53, 0x37, 0x52, 0x1A, 0x32, 0x01,
            0xB5, 0xBF, 0x5A, 0x1F, 0xF4, 0x23, 0x5D, 0xAC, 0xF0, 0xDA, 0xCD, 0x61, 0xAB, 0x1A,
            0x32, 0x01, 0xB5, 0xBF, 0x5A, 0xF0, 0xCD, 0x11, 0x5D, 0xA0, 0xF9, 0xE7, 0x14, 0x6E,
            0x1E, 0x1A, 0x32, 0x01, 0xB5, 0xBF, 0x5B, 0xE7, 0xBC, 0x6C, 0x5D, 0xA4, 0x4C, 0xFD,
            0x32, 0x04, 0x1A, 0x1A,
        ];

        let frames = format_adsb_beast_frames_from_bytes(&raw_frame);
        for frame in frames.frames.iter() {
            info!("Frame: {:02X?}", frame);
        }

        assert!(
            frames.frames.len() == 24,
            "Expected 24 frame, got {}",
            frames.frames.len()
        );

        assert!(
            frames.left_over.len() == 0,
            "Expected 0 leftover bytes, got {}",
            frames.left_over.len(),
        );
    }
}
